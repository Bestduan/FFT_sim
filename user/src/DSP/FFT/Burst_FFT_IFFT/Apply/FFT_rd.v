//Testbench for module pgr_fft_top, generated by tb_gen.pl

`timescale 1 ns/1 ps
module fft_rd #(
    parameter   FFT_LENGTH          =   1023,   //len = 1023+1
    parameter   BUTTERFLY_LAT       =   1,      //
    parameter   FFT_MODE            =   0,      //0:"FFT"; 1:"IFFT"
    parameter   SIG_MODE            =   1,      //1:signed; 0:unsigned
    parameter   DATA_WIDTH          =   16,     //8~
    parameter   TWIDDLE_WIDTH       =   16,     //8~
    parameter   ADDR_WIDTH          =   9       //FFT_LENGTH = 2(ADDR_WIDTH+1)
) (
    input  wire                     sys_clk,//
    input  wire                     sys_rst_n,

    output wire [2*DATA_WIDTH-1:0]  m_axi_data,
    output wire [ADDR_WIDTH : 0]    m_axi_user,//index
    output wire                     m_axi_last,
    output wire                     m_axi_valid,
    output reg                      led,
    output wire                     status
);

wire                        fft_start;
wire                        cfg_valid;
wire    [23:0]              cfg_data;
wire                        cfg_ready;
wire                        s_axi_valid;
wire                        s_axi_last;
wire    [2*DATA_WIDTH-1:0]  s_axi_data;
wire                        s_axi_ready;
wire                        m_axi_ready;
reg    [9:0]                addr_rom;
wire   [31:0]               data_rom;
reg    [31:0]               m_axi_data0;
reg                         m_axi_valid0;


assign m_axi_ready = 1'b1;

fft_start fft_start_u(
	.clk         ( sys_clk     ),
	.rst_n       ( sys_rst_n   ),
	.m_axi_last  ( m_axi_last  ),
	.m_axi_valid ( m_axi_valid ),
	.fft_start   ( fft_start   )
);

fft_top #(
	.FFT_LENGTH ( FFT_LENGTH ),
	.DATA_WIDTH ( DATA_WIDTH ),
	.ADDR_WIDTH ( ADDR_WIDTH )
) fft_top_u (
	.clk         ( sys_clk     ),
	.rst_n       ( sys_rst_n   ),

	.cfg_valid   ( cfg_valid   ),
	.cfg_data    ( cfg_data    ),
	.cfg_ready   ( cfg_ready   ),

	.s_axi_valid ( s_axi_valid ),
	.s_axi_last  ( s_axi_last  ),
	.s_axi_data  ( s_axi_data  ),
	.s_axi_ready ( s_axi_ready ),
	
	.m_axi_data  ( m_axi_data  ),
	.m_axi_user  ( m_axi_user  ),
	.m_axi_last  ( m_axi_last  ),
	.m_axi_valid ( m_axi_valid ),
	.m_axi_ready ( m_axi_ready )
);

fft_src_in #(
	.FFT_LENGTH ( FFT_LENGTH   ),
	.DATA_WIDTH ( 2*DATA_WIDTH ),
	.ADDR_WIDTH ( ADDR_WIDTH   )
) fft_src_in_u (
	.clk         ( sys_clk     ),
	.rst_n       ( sys_rst_n   ),
	.fft_start   ( fft_start   ),
	.cfg_valid   ( cfg_valid   ),
	.cfg_data    ( cfg_data    ),
	.cfg_ready   ( cfg_ready   ),
	.s_axi_valid ( s_axi_valid ),
	.s_axi_last  ( s_axi_last  ),
	.s_axi_data  ( s_axi_data  ),
	.s_axi_ready ( s_axi_ready )
);

assign status = m_axi_valid0;

rom_fft_out  u_rom_fft_out(
	.addr     ( addr_rom   ),
	.rd_data  ( data_rom   ),
	.clk      ( sys_clk    ),
	.rst      ( !sys_rst_n )
);

always @(posedge sys_clk or negedge sys_rst_n) begin
    if(!sys_rst_n)
        addr_rom <= {10{1'b0}};
    else if(m_axi_valid)
        addr_rom <= addr_rom + { {9{1'b0}}, 1'b1};
    else
        addr_rom <= {10{1'b0}};
end

always @(posedge sys_clk or negedge sys_rst_n) begin
    if(!sys_rst_n) begin
        m_axi_data0  <= 0;
        m_axi_valid0 <= 0;
    end
    else begin
        m_axi_data0  <= m_axi_data;
        m_axi_valid0 <= m_axi_valid;
    end
end

//------------test----------------------------
reg     m_axi_valid0_r1;
reg     m_axi_valid0_r2;
reg     d_err0;
reg     d_err1;

always @(posedge sys_clk or negedge sys_rst_n) begin
    if(!sys_rst_n) begin
        m_axi_valid0_r1 <= 0;
        m_axi_valid0_r2 <= 0;
    end
    else begin
        m_axi_valid0_r1 <= m_axi_valid0;
        m_axi_valid0_r2 <= m_axi_valid0_r1;
    end
end

always @(posedge sys_clk or negedge sys_rst_n) begin
    if(!sys_rst_n)
        d_err0 <= 1'b0;
    else if(~m_axi_valid0_r1 & m_axi_valid0 )
        d_err0 <= ~(m_axi_data0 == 32'h00000032);
end

always @(posedge sys_clk or negedge sys_rst_n) begin
    if(!sys_rst_n)
        d_err1 <= 1'b0;
    else if(~m_axi_valid0_r2 & m_axi_valid0_r1 )
        d_err1 <= ~(m_axi_data0 == 32'hFFFD0032);
end
//------------test----------------------------

always @(posedge sys_clk or negedge sys_rst_n) begin
    if(!sys_rst_n)
        led <= 1'b0;
    else if(d_err1 | d_err0)
        led <= 1'b1;
    else if(m_axi_valid0)
        led <= ~(data_rom == m_axi_data0);
    else
        led <= 1'b0;
end

endmodule
