// Generated by IP Generator (Version PDS_2017.1B build 19665)


//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2014 PANGO MICROSYSTEMS, INC
// ALL RIGHTS REVERVED.
//
// THE SOURCE CODE CONTAINED HEREIN IS PROPRIETARY TO PANGO MICROSYSTEMS, INC.
// IT SHALL NOT BE REPRODUCED OR DISCLOSED IN WHOLE OR IN PART OR USED BY
// PARTIES WITHOUT WRITTEN AUTHORIZATION FROM THE OWNER.
//
//////////////////////////////////////////////////////////////////////////////
// Library:
// Filename:drm_32x512.v
//////////////////////////////////////////////////////////////////////////////
//(*bram_map = "yes"*)
//(* RAM_STYLE="{AUTO | BLOCK |  BLOCK_POWER1 | BLOCK_POWER2}" *)
module drm_32x512 #
(
    parameter    ADDR_WIDTH     =   9,
    parameter    DATA_WIDTH     =   32
)
(
    input   wire    [DATA_WIDTH-1:0]    wr_data  , //input write data
    input   wire    [ADDR_WIDTH-1:0]    wr_addr  , //input write address
    input   wire                        wr_en    , //input write enable
    input   wire                        wr_clk   , //input write clock
    input   wire                        wr_rst   , //input write reset

    output  reg     [DATA_WIDTH-1:0]    rd_data  , //output read data
    input   wire    [ADDR_WIDTH-1:0]    rd_addr  , //input read address
    input   wire                        rd_clk   , //input read clock
    input   wire                        rd_clk_en, //input read clock enable
    input   wire                        rd_rst     //input read reset
);

localparam  DEPTH = 2**ADDR_WIDTH;

reg     [DATA_WIDTH-1:0]  mem [0:DEPTH-1];

//genvar i;
//generate
//for(i=0; i<= DEPTH-1; i=i+1 )
//begin:loop
////    always@(posedge wr_clk or posedge wr_rst)
//    always@(posedge wr_clk)
//    begin
//        if(wr_rst)
//            mem[i] <= {DATA_WIDTH{1'b0}};
//        else if(wr_en & (wr_addr == i) )
//            mem[i] <= wr_data;
//    end
//end
//endgenerate
//always@(posedge wr_clk)
//begin
//    if(wr_rst)
//        mem[wr_addr] <= {DATA_WIDTH{1'b0}};
//    else if(wr_en)
//        mem[wr_addr] <= wr_data;
//end
//
//
////always@(posedge rd_clk or posedge rd_rst)
//always@(posedge rd_clk)
//begin
//    if(rd_rst)
//        rd_data <= {DATA_WIDTH{1'b0}};
//    else if( rd_clk_en )
//        rd_data <= mem[rd_addr];
//end

always@(posedge wr_clk)
begin
    if(wr_en)
        mem[wr_addr] <= wr_data;
end


//always@(posedge rd_clk or posedge rd_rst)
always@(posedge rd_clk)
begin
    if( rd_clk_en )
        rd_data <= mem[rd_addr];
end

endmodule
